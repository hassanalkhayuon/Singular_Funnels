% This code is created by Hassan Alkhayuon to
% find the distence between the branches of stable manifold in
% terms of eps for a given rotation
% A Research project with Serhiy Yanchuk and Hildeberto Jard√≥n-Kojakhmetov

clear
warning off

% Colour-blind friendly colour
[red,yellow,green,blue ] = ...
    Colour_blind_friendly_colours();

%% Parameters
I = -4;
eta = 10; % adaptive parameters
alpha = pi/2; % phase shift.

rot = 10;

%% equilibria
phi_e1 = ...
    mod(asin( (I+eta)/( sqrt( (1-eta)^2 + 2*eta*(1+cos(alpha)) ) ) ) - ...
    atan( eta*sin(alpha)/( 1+eta*cos(alpha) ) ), 2*pi) ;

mu_e1 = sin(phi_e1) - I;

phi_e2 = mod(pi - ...
    asin( (I+eta)/( sqrt( (1-eta)^2 + 2*eta*(1+cos(alpha)) ) ) ) - ...
    atan( eta*sin(alpha)/( 1+eta*cos(alpha) ) ), 2*pi);

mu_e2 = sin(phi_e2) - I;


%% ode setting
res = 100;
EPS_scan1 = linspace(0.005, 0.099,500);
EPS_scan2 = linspace(0.1, 1,res);
EPS_scan = [EPS_scan1, EPS_scan2];
for ind_eps = 1:length(EPS_scan)
    EPS = EPS_scan(ind_eps);
    par = [I, eta, alpha, EPS];
    opts = odeset(...
        'RelTol',1e-10,...
        'AbsTol',1e-10,...
        'Events',@myeventfun);
    odefun = @(t,var)Adaptive_phase_ode(var,par);

    TT = 100;

    %% computing the stable manifold of e2
    % stable manifold of the saddel
    %
    initcond_m = [phi_e2 mu_e2] - 0.001.*[1 0];

    for ind_man = 1:rot+1

        [t, var] = ode45(odefun,[TT 0],initcond_m,opts);

        initcond_m = [2*pi - var(end,1), var(end,2)];


        phi = var(:,1);
        mu = var(:,2);


        tstart = t(end);

    end
    end_point_1 = var(end,:);

    initcond_p = [phi_e2 mu_e2] + 0.001.*[1 0];
    %
    for ind_man = 1:rot

        [t, var] = ode45(odefun,[TT 0],initcond_p,opts);

        initcond_p = [2*pi - var(end,1), var(end,2)];

        phi = var(:,1);
        mu = var(:,2);



        tstart = t(end);
    end

    end_point_2 = var(end,:);

    dist(ind_eps) = norm(end_point_1 - end_point_2);
end

figure(5);
hold on
plot(EPS_scan,dist)

% %
% % critical manifold
% %
% 
% phi01 = linspace(0, pi/2, 1000);
% phi02 = linspace(pi/2, 3*pi/2 ,1000);
% phi03 = linspace(3*pi/2, 2*pi,1000);
% 
% mu01 = -I + sin(phi01);
% mu02 = -I + sin(phi02);
% mu03 = -I + sin(phi03);
% 
% plot(mu01,phi01,'-','Color',[blue])
% plot(mu02,phi02,'--','Color',[blue])
% plot(mu03,phi03,'-','Color',[blue])
% 
% % trajectories
% %
% 
% % cylindrical limit cycle
% % plot([mu_LC mu_LC], [0 2*pi],'-b','LineWidth',3)
% 
% % equilibria
% plot(...
%     mu_e1,phi_e1,'.','MarkerSize',25, 'Color', [blue])
% plot(...
%     mu_e2,phi_e2,'ok','MarkerSize',5.5,'LineWidth',2, 'Color', [blue])
% box on
% ylim([0 2*pi])
% % xlim([-4 6])

%% ODE function
function [dvar] = Adaptive_phase_ode(var,par)

% model parameters

I       = par(1);
eta     = par(2);
alpha   = par(3);
EPS     = par(4);


% variables
phi = var(1);
mu = var(2);

% diffrential equations
dphi = I + mu - sin(phi);
dmu  = EPS*(-mu + eta*(1 - sin(phi + alpha)));

dvar = [dphi; dmu];
end


%% event function
function [check,stop,direction] = myeventfun(t,var)
check = (var(1) - 2*pi)*var(1);
stop = 1;  % Halt integration
direction = 0;
end
